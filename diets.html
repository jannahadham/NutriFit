<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Traffic Flow Simulation: Math of Congestion</title>

<!-- p5.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

 <link rel="icon" type="image/png" href="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTIf1UsthSmB9pgA9nA9TOBHuGEi5SBcciJpQ&s">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root {
--bg: #0f1724;
--panel: #0b1220;
--accent: #28b8ff;
--muted: #98a0b3;
--glass: rgba(255, 255, 255, 0.03);
--card: #0d1522;
}
html,
body {
height: 100%;
margin: 0;
font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
Roboto, "Helvetica Neue", Arial;
background: linear-gradient(
180deg,
#061026 0%,
#07162a 50%,
#0b1b2b 100%
);
color: #e6eef7;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
}

.app {
display: grid;
grid-template-columns: 1fr 360px;
gap: 20px;
padding: 22px;
max-width: 1400px;
margin: 18px auto;
}

.panel {
background: linear-gradient(
180deg,
rgba(255, 255, 255, 0.02),
rgba(255, 255, 255, 0.01)
);
border-radius: 12px;
padding: 16px;
box-shadow: 0 6px 30px rgba(0, 0, 0, 0.5),
inset 0 1px 0 rgba(255, 255, 255, 0.02);
border: 1px solid rgba(255, 255, 255, 0.03);
}

.left {
display: flex;
flex-direction: column;
gap: 12px;
min-height: 600px;
}

#canvas-holder {
background: linear-gradient(
180deg,
rgba(255, 255, 255, 0.01),
rgba(255, 255, 255, 0.02)
);
border-radius: 10px;
padding: 8px;
display: flex;
align-items: center;
justify-content: center;
}

canvas {
display: block;
border-radius: 8px;
background: linear-gradient(
180deg,
rgba(0, 0, 0, 0.2),
rgba(0, 0, 0, 0.25)
);
}

.right {
display: flex;
flex-direction: column;
gap: 12px;
}

.control-row {
display: flex;
gap: 10px;
align-items: center;
justify-content: space-between;
}

label {
font-size: 13px;
color: var(--muted);
margin-bottom: 6px;
display: block;
}

input[type="range"] {
width: 100%;
accent-color: var(--accent);
}

.small {
font-size: 12px;
color: #bcd5ee;
}

.stat-grid {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 10px;
}

.stat-card {
background: rgba(255, 255, 255, 0.02);
border-radius: 8px;
padding: 10px;
}

.btn {
cursor: pointer;
padding: 8px 12px;
border-radius: 8px;
border: 1px solid rgba(255, 255, 255, 0.06);
background: linear-gradient(
180deg,
rgba(255, 255, 255, 0.02),
rgba(255, 255, 255, 0.01)
);
color: #eaf6ff;
font-weight: 600;
}

.muted {
color: var(--muted);
}

.top-bar {
display: flex;
justify-content: space-between;
align-items: center;
gap: 12px;
}

h1 {
margin: 4px 0 2px 0;
font-size: 18px;
letter-spacing: 0.2px;
}
p.desc {
margin: 0;
color: var(--muted);
font-size: 13px;
}

#chart-wrap {
margin-top: 12px;
background: var(--card);
border-radius: 8px;
padding: 8px;
}

footer.note {
margin-top: 12px;
color: var(--muted);
font-size: 12px;
}

.controls {
display: grid;
gap: 12px;
}

.input-inline {
display: flex;
gap: 10px;
align-items: center;
}

.small-muted {
font-size: 12px;
color: var(--muted);
}
:root {
--bg: #081223;
--panel: rgba(255, 255, 255, 0.03);
--accent: #28b8ff;
--muted: #98a0b3;
--card: rgba(255, 255, 255, 0.02);
}

html,
body {
height: 100%;
margin: 0;
font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
Roboto, "Helvetica Neue", Arial;
background: radial-gradient(
circle at 30% 20%,
rgba(15, 25, 45, 0.9),
rgba(5, 10, 20, 1)
),
linear-gradient(180deg, #071226, #0b1525);
color: #e6eef7;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
}

.app {
display: grid;
grid-template-columns: 1fr 360px;
gap: 20px;
padding: 22px;
max-width: 1400px;
margin: 18px auto;
}

/* Unified glassy panel look */
.panel {
background: var(--panel);
backdrop-filter: blur(10px);
border-radius: 12px;
padding: 16px;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.45),
inset 0 1px 0 rgba(255, 255, 255, 0.04);
border: 1px solid rgba(255, 255, 255, 0.04);
}

.left {
display: flex;
flex-direction: column;
gap: 12px;
min-height: 600px;
}

/* Fix color mismatch here */
#canvas-holder {
background: var(--card);
border-radius: 10px;
padding: 8px;
display: flex;
align-items: center;
justify-content: center;
box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.25);
}

canvas {
display: block;
border-radius: 8px;
background: radial-gradient(
circle at 50% 60%,
rgba(0, 0, 0, 0.3),
rgba(0, 0, 0, 0.4)
);
}

.right {
display: flex;
flex-direction: column;
gap: 12px;
}

.control-row {
display: flex;
gap: 10px;
align-items: center;
justify-content: space-between;
}

label {
font-size: 13px;
color: var(--muted);
margin-bottom: 6px;
display: block;
}

input[type="range"] {
width: 100%;
accent-color: var(--accent);
}

input[type="number"] {
background: rgba(255, 255, 255, 0.04);
color: #eaf4ff;
border: 1px solid rgba(255, 255, 255, 0.08);
border-radius: 6px;
padding: 6px 8px;
}

.small {
font-size: 12px;
color: #bcd5ee;
}

.stat-grid {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 10px;
}

.stat-card {
background: rgba(255, 255, 255, 0.02);
border-radius: 8px;
padding: 10px;
}

.btn {
cursor: pointer;
padding: 8px 12px;
border-radius: 8px;
border: 1px solid rgba(255, 255, 255, 0.06);
background: linear-gradient(
180deg,
rgba(255, 255, 255, 0.05),
rgba(255, 255, 255, 0.02)
);
color: #eaf6ff;
font-weight: 600;
transition: background 0.2s, transform 0.1s;
}

.btn:hover {
background: rgba(40, 184, 255, 0.15);
transform: translateY(-1px);
}

.top-bar {
display: flex;
justify-content: space-between;
align-items: center;
gap: 12px;
}

h1 {
margin: 4px 0 2px 0;
font-size: 18px;
letter-spacing: 0.2px;
}
p.desc {
margin: 0;
color: var(--muted);
font-size: 13px;
}

#chart-wrap {
margin-top: 12px;
background: var(--card);
border-radius: 8px;
padding: 8px;
}

footer.note {
margin-top: 12px;
color: var(--muted);
font-size: 12px;
}

.controls {
display: grid;
gap: 12px;
}
</style>
</head>
<body>
<div class="app">
<div class="panel left">
<div class="top-bar">
<div>
<h1>Traffic Flow Simulation — Math of Congestion</h1>
<p class="desc">
A circular one-lane road. Model:
<em>dv/dt = a (1 − v/v<sub>max</sub>) (1 − ρ/ρ<sub>max</sub>)</em
>, plus safety braking and random slowdowns to produce stop-and-go
waves.
</p>
</div>
<div style="text-align: right">
<div class="small-muted">
Road length: <strong id="road-length-display">1000</strong> m
</div>
<div class="small-muted">
Car length: <strong id="car-length-display">5</strong> m
</div>
</div>
</div>

<div id="canvas-holder" style="height: 520px" class="panel">
<!-- p5 canvas inserted here -->
<div id="p5-root" style="width: 100%; height: 100%"></div>
</div>

<div
style="
display: flex;
gap: 12px;
align-items: center;
justify-content: space-between;
"
>
<div>
<button id="pause-btn" class="btn">Pause</button>
<button id="reset-btn" class="btn">Reset</button>
<button
id="sweep-btn"
class="btn"
title="Sweep densities and build fundamental diagram"
>
Sweep Densities
</button>
</div>
<div style="text-align: right">
<div class="small-muted">
Average speed: <strong id="avg-speed">0</strong> m/s
</div>
<div class="small-muted">
Flow (ρ·v): <strong id="flow">0</strong>
</div>
</div>
</div>

<div id="chart-wrap" class="panel">
<canvas id="fundamentalChart" height="130"></canvas>
</div>

<footer>
<p>© 2025 — @Jannah Adham</p>
</footer>
</div>

<div class="panel right">
<div class="controls">
<div>
<label
>Density — number of cars (<span id="num-cars-display">30</span
>)</label
>
<input
id="density-range"
type="range"
min="5"
max="120"
value="30"
step="1"
/>
<div class="small-muted">
Higher → more cars on the ring, waves more likely.
</div>
</div>

<div>
<label
>Maximum speed v<sub>max</sub> (m/s) — (<span id="vmax-display"
>30</span
>)</label
>
<input
id="vmax-range"
type="range"
min="5"
max="40"
value="30"
step="1"
/>
</div>

<div>
<label
>Acceleration a (m/s²) — (<span id="a-display">1.0</span>)</label
>
<input
id="a-range"
type="range"
min="0.2"
max="3.0"
step="0.1"
value="1.0"
/>
</div>

<div>
<label
>Stochastic braking probability p<sub>brake</sub> — (<span
id="pbrake-display"
>0.03</span
>)</label
>
<input
id="pbrake-range"
type="range"
min="0"
max="0.2"
step="0.005"
value="0.03"
/>


<div>
<label
>Safe gap factor (multiplier of car length) — (<span
id="safe-display"
>1.5</span
>×)</label
>
<input
id="safe-range"
type="range"
min="1"
max="4"
step="0.1"
value="1.5"
/>
<div class="small-muted">
Larger → drivers keep more distance, fewer jams.
</div>
</div>

<div style="display: flex; gap: 8px">
<div style="flex: 1">
<label>Road length L (m)</label>
<input
id="L-input"
type="number"
min="200"
max="5000"
step="50"
value="1000"
style="width: 100%"
/>
</div>
<div style="width: 108px">
<label>Car length (m)</label>
<input
id="carlen-input"
type="number"
min="2"
max="10"
step="0.5"
value="5"
style="width: 100%"
/>
</div>
</div>

<div class="stat-grid">
<div class="stat-card">
<div class="small-muted">Traffic model</div>
<div>
<strong
>dv/dt = a (1 − v/v<sub>max</sub>)(1 −
ρ/ρ<sub>max</sub>)</strong
>
</div>
<div class="small-muted">
+ safety braking + stochastic slowdowns
</div>
</div>
<div class="stat-card">
<div class="small-muted">Controls</div>
<div><strong>Drag sliders → see dynamics change</strong></div>
<div class="small-muted">Sweep builds fundamental diagram.</div>
</div>
</div>
</div>
</div>
</div>


<style>
footer {
text-align: center;
padding: 1rem 0;
font-size: 0.95rem;
color: #666;
}
</style>

<script>
const config = {
fps: 60,
dt: 1 / 60, // simulation timestep in seconds (Euler)
initialCars: 30,
L: 1000, // meters
car_length: 5, // meters
};

let sim; // simulation object (created in setup)
let chart;

// Helper: map numeric to color (blue -> red)
function speedToColorFraction(f) {
// f in [0,1] where 0=slow,1=fast
const r = Math.min(255, Math.floor(255 * Math.pow(1.2 - f * 0.9, 1)));
const g = Math.min(255, Math.floor(120 + 135 * f));
const b = Math.min(255, Math.floor(255 * f * 0.7));
return `rgb(${r},${g},${b})`;
}

// Simulation code (no p5 dependency)
class TrafficSim {
constructor(params) {
this.L = params.L;
this.N = params.N;
this.carLen = params.carLen;
this.vmax = params.vmax;
this.a = params.a;
this.p_brake = params.p_brake;
this.safeFactor = params.safeFactor;

this.rho_max = 1 / this.carLen; // cars per meter (bumper-to-bumper)
this.positions = [];
this.speeds = [];
this.initCars(this.N);
}

initCars(N) {
this.positions = [];
this.speeds = [];
// Place cars evenly initially, with slight random jitter in position and speed
for (let i = 0; i < N; ++i) {
const x =
(i / N) * this.L + (Math.random() - 0.5) * (this.L / N) * 0.1;
this.positions.push((x + this.L) % this.L);
// initial speed near vmax
const v = this.vmax * (0.7 + 0.3 * Math.random());
this.speeds.push(v);
}
this.sortByPosition();
}

sortByPosition() {
const idx = this.positions
.map((p, i) => i)
.sort((i, j) => this.positions[i] - this.positions[j]);
this.positions = idx.map((i) => this.positions[i]);
this.speeds = idx.map((i) => this.speeds[i]);
}

step(dt) {
const N = this.positions.length;
if (N === 0) return;
// compute next positions and speeds using Euler integration
const newSpeeds = new Array(N);
for (let i = 0; i < N; ++i) {
const x = this.positions[i];
const v = this.speeds[i];
// index of car ahead (wrap)
const j = (i + 1) % N;
const xnext = this.positions[j];
// gap: distance from front bumper to rear bumper ahead minus car length
let gap = xnext - x;
if (gap <= 0) gap += this.L;
gap = gap - this.carLen;
if (gap < 0) gap = 0;

// local density: approximate cars per meter using spacing = gap + carLen
const spacing = gap + this.carLen; // space per car
let rho_local = 1.0 / spacing; // cars per meter
// clamp
rho_local = Math.min(rho_local, this.rho_max);

// main differential model:
// dv/dt = a * (1 - v/vmax) * (1 - rho_local / rho_max)
let dvdt =
this.a * (1 - v / this.vmax) * (1 - rho_local / this.rho_max);

// safety braking: if gap smaller than safe_distance trigger deceleration
const safe_distance = this.safeFactor * this.carLen + 0.5 * v; // include small speed-dependent buffer
if (gap < safe_distance) {
// decelerate proportionally to how much smaller than safe distance
const ratio = Math.max(0, 1 - gap / safe_distance);
const emergencyBrake = -3.0 - 4.0 * ratio; // strong braking
dvdt += emergencyBrake;
}

// stochastic braking: sudden small negative jerk with some prob
if (Math.random() < this.p_brake) {
dvdt += -1.5 * (0.5 + Math.random());
}



// integrate
let vnext = v + dvdt * dt;
// clamp
if (vnext < 0) vnext = 0;
if (vnext > this.vmax * 1.2) vnext = this.vmax * 1.2; // allow slight overshoot

newSpeeds[i] = vnext;
}

// update speeds then positions
for (let i = 0; i < N; ++i) {
this.speeds[i] = newSpeeds[i];
// update position
this.positions[i] += this.speeds[i] * dt;
// wrap around
if (this.positions[i] >= this.L) this.positions[i] -= this.L;
if (this.positions[i] < 0) this.positions[i] += this.L;
}

// sorting is not strictly needed if no overtaking occurs, but small numerical reorders can happen; ensure ordering
this.sortByPosition();
}

setParams(params) {
if (params.L !== undefined) this.L = params.L;
if (params.carLen !== undefined) {
this.carLen = params.carLen;
this.rho_max = 1 / this.carLen;
}
if (params.N !== undefined) {
// if N changed, re-init for simplicity (keeps design simple & stable)
this.N = params.N;
this.initCars(this.N);
}
if (params.vmax !== undefined) this.vmax = params.vmax;
if (params.a !== undefined) this.a = params.a;
if (params.p_brake !== undefined) this.p_brake = params.p_brake;

if (params.safeFactor !== undefined)
this.safeFactor = params.safeFactor;
}

averageSpeed() {
if (this.speeds.length === 0) return 0;
return this.speeds.reduce((s, x) => s + x, 0) / this.speeds.length;
}

densityGlobal() {
// cars per meter
return this.positions.length / this.L;
}

flow() {
return this.densityGlobal() * this.averageSpeed();
}
}

// p5 sketch
let sketch = (p) => {
let canvasW, canvasH;
let ringRadius;
let centerX, centerY;
let paused = false;

p.setup = function () {
const holder = document.getElementById("p5-root");
canvasW = holder.clientWidth;
canvasH = holder.clientHeight;
// create canvas that fills holder
const c = p.createCanvas(canvasW, canvasH);
c.parent("p5-root");
p.frameRate(config.fps);

// initial sim
sim = new TrafficSim({
L: config.L,
N: config.initialCars,
carLen: config.car_length,
vmax: 30,
a: 1.0,
p_brake: 0.03,
safeFactor: 1.5,
});

ringRadius = Math.min(canvasW, canvasH) * 0.36;
centerX = canvasW * 0.5;
centerY = canvasH * 0.52;

setupUI();
setupChart();
};

p.windowResized = function () {
const holder = document.getElementById("p5-root");
const w = holder.clientWidth;
const h = holder.clientHeight;
p.resizeCanvas(w, h);
canvasW = w;
canvasH = h;
ringRadius = Math.min(canvasW, canvasH) * 0.36;
centerX = canvasW * 0.5;
centerY = canvasH * 0.52;
};

p.draw = function () {
const dt = config.dt;
if (!paused) {
// run several internal substeps for stability if dt large
sim.step(dt);
}

// background & ring
p.clear();
p.push();
// subtle background circle
p.noStroke();
p.fill(10, 18, 34, 220);
p.rect(0, 0, canvasW, canvasH, 10);

// outer ring shadow
p.translate(centerX, centerY);
p.noFill();
p.stroke(20, 40, 80);
p.strokeWeight(18);
p.ellipse(0, 0, ringRadius * 2.1, ringRadius * 2.1);
p.pop();

// road ring
p.push();
p.translate(centerX, centerY);
p.noFill();
// road track
p.stroke(35, 60, 90);
p.strokeWeight(34);
p.ellipse(0, 0, ringRadius * 2.0 + 8, ringRadius * 2.0 + 8);

// dashed centerline to help visualize waves
p.stroke(60, 110, 170, 140);
p.strokeWeight(2);
const dashCount = 120;
for (let i = 0; i < dashCount; i++) {
const a1 = (i / dashCount) * Math.PI * 2;
const a2 = ((i + 0.5) / dashCount) * Math.PI * 2;
const r = ringRadius;
const x1 = Math.cos(a1) * r;
const y1 = Math.sin(a1) * r;
const x2 = Math.cos(a2) * r;
const y2 = Math.sin(a2) * r;
p.line(x1, y1, x2, y2);
}

// ticks for meters
p.stroke(10, 20, 40, 120);
p.strokeWeight(1);
for (let i = 0; i < 24; i++) {
const a = (i / 24) * Math.PI * 2;
const r1 = ringRadius * 0.92;
const r2 = ringRadius * 1.05;
p.line(
Math.cos(a) * r1,
Math.sin(a) * r1,
Math.cos(a) * r2,
Math.sin(a) * r2
);
}

// draw cars
const N = sim.positions.length;
for (let i = 0; i < N; i++) {
const pos = sim.positions[i];
const v = sim.speeds[i];
// map position along ring: pos/L * 2pi with offset to rotate slowly so patterns drift
const theta =
(pos / sim.L) * Math.PI * 2 - performance.now() * 0.00002;
const x = Math.cos(theta) * ringRadius;
const y = Math.sin(theta) * ringRadius;

// color by speed fraction relative to vmax
const f = Math.min(1, Math.max(0, v / sim.vmax));
const col = speedToColorFraction(f);
p.push();
p.translate(x, y);
// orientation based on tangent
p.rotate(theta + Math.PI / 2);
// car rectangle
p.noStroke();
p.fill(col);
const w = sim.carLen * 1.6; // visual size scaling
const h = Math.max(6, Math.min(18, sim.carLen * 1.4));
// car body
p.rectMode(p.CENTER);
p.rect(0, 0, w, h, 3);
// windows
p.fill(255, 255, 255, 120);
p.rect(0, -2, w * 0.5, h * 0.45, 2);
p.pop();
}

// overlay stats
p.push();
p.noStroke();
p.fill(255, 255, 255, 220);
p.textSize(14);
p.textAlign(p.LEFT, p.TOP);
p.text(
"Density (global): " +
(sim.densityGlobal() * 1000).toFixed(2) +
" cars/km",
14,
12
);
p.text(
"Avg speed: " + sim.averageSpeed().toFixed(2) + " m/s",
14,
32
);
p.text("Flow: " + sim.flow().toFixed(2) + " (cars·m/s / m)", 14, 52);
p.pop();

// update UI numeric displays
document.getElementById("avg-speed").textContent = sim
.averageSpeed()
.toFixed(2);
document.getElementById("flow").textContent = sim.flow().toFixed(2);
document.getElementById("road-length-display").textContent =
sim.L.toFixed(0);
document.getElementById("car-length-display").textContent =
sim.carLen.toFixed(1);

// update chart point (live)
updateChartPoint(sim.densityGlobal() * 1000, sim.averageSpeed()); // density per km for chart axes
};

// UI and Chart setup
function setupUI() {
// get elements
const densityRange = document.getElementById("density-range");
const numDisplay = document.getElementById("num-cars-display");
densityRange.value = sim.N;
numDisplay.textContent = sim.N;

const vmaxRange = document.getElementById("vmax-range");
const aRange = document.getElementById("a-range");
const pBrakeRange = document.getElementById("pbrake-range");
const safeRange = document.getElementById("safe-range");
const Linput = document.getElementById("L-input");
const carlenInput = document.getElementById("carlen-input");

// displays
const vmaxDisp = document.getElementById("vmax-display");
const aDisp = document.getElementById("a-display");
const pbrDisp = document.getElementById("pbrake-display");
const safeDisp = document.getElementById("safe-display");
const numCarsDisp = numDisplay;

document
.getElementById("density-range")
.addEventListener("input", (e) => {
const newN = Math.max(2, Math.round(Number(e.target.value)));
numCarsDisp.textContent = newN;
});
document
.getElementById("density-range")
.addEventListener("change", (e) => {
const newN = Math.max(2, Math.round(Number(e.target.value)));
sim.setParams({ N: newN });
});

vmaxRange.addEventListener("input", (e) => {
vmaxDisp.textContent = e.target.value;
});
vmaxRange.addEventListener("change", (e) => {
sim.setParams({ vmax: Number(e.target.value) });
});

aRange.addEventListener(
"input",
(e) => (aDisp.textContent = Number(e.target.value).toFixed(1))
);
aRange.addEventListener("change", (e) =>
sim.setParams({ a: Number(e.target.value) })
);

pBrakeRange.addEventListener(
"input",
(e) => (pbrDisp.textContent = Number(e.target.value))
);
pBrakeRange.addEventListener("change", (e) =>
sim.setParams({ p_brake: Number(e.target.value) })
);


safeRange.addEventListener(
"input",
(e) => (safeDisp.textContent = Number(e.target.value))
);
safeRange.addEventListener("change", (e) =>
sim.setParams({ safeFactor: Number(e.target.value) })
);

Linput.addEventListener("change", (e) => {
const v = Math.max(200, Number(e.target.value));
sim.setParams({ L: v });
document.getElementById("road-length-display").textContent =
v.toFixed(0);
});

carlenInput.addEventListener("change", (e) => {
const v = Math.max(2, Number(e.target.value));
sim.setParams({ carLen: v });
document.getElementById("car-length-display").textContent =
v.toFixed(1);
});

// buttons
const pauseBtn = document.getElementById("pause-btn");
const resetBtn = document.getElementById("reset-btn");
const sweepBtn = document.getElementById("sweep-btn");

pauseBtn.addEventListener("click", () => {
paused = !paused;
pauseBtn.textContent = paused ? "Resume" : "Pause";
});

resetBtn.addEventListener("click", () => {
// re-init sim with current slider values
const N = Math.max(2, Math.round(Number(densityRange.value)));
const vmax = Number(vmaxRange.value);
const a = Number(aRange.value);
const pbr = Number(pBrakeRange.value);

const safeFactor = Number(safeRange.value);
const L = Number(Linput.value);
const carLen = Number(carlenInput.value);
sim = new TrafficSim({
L: L,
N: N,
carLen: carLen,
vmax: vmax,
a: a,
p_brake: pbr,
safeFactor: safeFactor,
});
});

sweepBtn.addEventListener("click", async () => {
// sweep densities and build fundamental diagram
sweepBtn.disabled = true;
sweepBtn.textContent = "Sweeping...";
await runDensitySweep();
sweepBtn.textContent = "Sweep Densities";
sweepBtn.disabled = false;
});

// initialize UI displays with sim values
vmaxRange.value = sim.vmax;
vmaxDisp.textContent = sim.vmax;
aRange.value = sim.a;
aDisp.textContent = sim.a.toFixed(1);
pBrakeRange.value = sim.p_brake;
pbrDisp.textContent = sim.p_brake;
safeRange.value = sim.safeFactor;
safeDisp.textContent = sim.safeFactor.toFixed(1);
Linput.value = sim.L;
carlenInput.value = sim.carLen;
}

// Chart.js live chart
function setupChart() {
const ctx = document
.getElementById("fundamentalChart")
.getContext("2d");

const data = {
datasets: [
{
label: "Avg speed (m/s) vs density (cars/km)",
data: [],
borderColor: "rgba(40,184,255,0.9)",
backgroundColor: "rgba(40,184,255,0.18)",
pointRadius: 3,
showLine: false,
},
],
};

chart = new Chart(ctx, {
type: "scatter",
data: data,
options: {
responsive: true,
maintainAspectRatio: false,
scales: {
x: {
type: "linear",
title: { display: true, text: "Density (cars/km)" },
min: 0,
max: 200,
},
y: {
title: { display: true, text: "Average speed (m/s)" },
min: 0,
max: 40,
},
},
plugins: {
legend: { display: false },
},
},
});
}

let lastChartUpdate = 0;
function updateChartPoint(densityPerKm, avgSpeed) {
// only push point occasionally to not overwhelm
const tnow = performance.now();
if (tnow - lastChartUpdate < 120) return;
lastChartUpdate = tnow;
// push but keep dataset limited
chart.data.datasets[0].data.push({ x: densityPerKm, y: avgSpeed });
if (chart.data.datasets[0].data.length > 500) {
chart.data.datasets[0].data.shift();
}
chart.update("none");
}

// Sweep densities to build fundamental diagram
async function runDensitySweep() {
// Save current sim state, then perform short runs at multiple densities to sample average speed
const saveSim = JSON.parse(
JSON.stringify({
L: sim.L,
carLen: sim.carLen,
vmax: sim.vmax,
a: sim.a,
p_brake: sim.p_brake,
safeFactor: sim.safeFactor,
})
);
const originalN = sim.positions.length;
// clear current chart dataset
chart.data.datasets[0].data = [];
// choose densities (cars per km)
const densitiesPerKm = [];
for (let k = 5; k <= 180; k += 5) densitiesPerKm.push(k);
// For each density, run a short simulation (warm-up + sample)
for (let dpk of densitiesPerKm) {
const d = dpk / 1000; // cars per m
const N = Math.max(2, Math.floor(d * saveSim.L));
// init a fresh sim for measurement
const measureSim = new TrafficSim({
L: saveSim.L,
N: N,
carLen: saveSim.carLen,
vmax: saveSim.vmax,
a: saveSim.a,
p_brake: saveSim.p_brake,
safeFactor: saveSim.safeFactor,
});

// warm up for 2 seconds
for (let t = 0; t < 2.0; t += config.dt) measureSim.step(config.dt);
// sample average speed across 3 seconds
let sum = 0;
let counter = 0;
for (let t = 0; t < 3.0; t += config.dt) {
measureSim.step(config.dt);
sum += measureSim.averageSpeed();
counter++;
}
const avg = counter > 0 ? sum / counter : 0;
chart.data.datasets[0].data.push({ x: dpk, y: avg });
chart.update("none");

// slight yield to keep UI responsive
await new Promise((r) => setTimeout(r, 30));
}

chart.update();
}
};


// attach p5
new p5(sketch, "p5-root");
</script>
</body>
</html>
